from .routing_modifiers import *
from .routing_actions import *
from .routing_subjects import SubjectBuiltin, SubjectCustom
from ..base import OptionsGroup
from ..exceptions import ConfigurationError
from ..utils import listify


class Var(object):

    tpl = '%s'

    def __init__(self, name):
        self._name = name

    def __str__(self):
        return self.tpl % self._name


class RouteRule(object):
    """Represents a routing rule."""

    class vars(object):
        """Routing variables."""

        class request(Var):
            """Returns request variable. Examples: PATH_INFO, SCRIPT_NAME, REQUEST_METHOD."""
            tpl = '${%s}'

        class metric(Var):
            """Returns metric (see ``monitoring``) variable."""
            tpl = '${metric[%s]}'

        class cookie(Var):
            """Returns cookie variable"""
            tpl = '${cookie[%s]}'

        class query(Var):
            """Returns query string variable."""
            tpl = '${qs[%s]}'

        class uwsgi(Var):
            """Returns internal uWSGI information.

             Supported variables:
                * wid
                * pid
                * uuid
                * status

            """
            tpl = '${uwsgi[%s]}'

        class time(Var):
            """Returns time/date in various forms.

            Supported variables:
                * unix

            """
            tpl = '${time[%s]}'

        class httptime(Var):
            """Returns http date adding the numeric argument (if specified)
            to the current time (use empty arg for current server time).

            """
            tpl = '${httptime[%s]}'

    class var_functions(object):
        """Functions that can be applied to variables."""

        class mime(Var):
            """Returns mime type of a variable."""
            tpl = '${mime[%s]}'

        class math(Var):
            """Perform a math operation. Example: CONTENT_LENGTH+1

            Supported operations: + - * /

            .. warning:: Requires matheval support.

            """
            tpl = '${math[%s]}'

        class base64(Var):
            """Encodes the specified var in base64"""
            tpl = '${base64[%s]}'

        class hex(Var):
            """Encodes the specified var in hex."""
            tpl = '${hex[%s]}'

        class upper(Var):
            """Uppercase the specified var."""
            tpl = '${upper[%s]}'

        class lower(Var):
            """Lowercase the specified var."""
            tpl = '${lower[%s]}'

    class stages(object):
        """During the request cycle, various stages (aka chains) are processed.

        Chains can be "recursive". A recursive chain can be called multiple times
        in a request cycle.

        """

        REQUEST = ''
        """Applied before the request is passed to the plugin."""

        ERROR = 'error'
        """Applied as soon as an HTTP status code is generate. **Recursive chain**."""

        RESPONSE = 'response'
        """Applied after the last response header has been generated (just before sending the body)."""

        FINAL = 'final'
        """Applied after the response has been sent to the client."""

    class subjects(object):
        """Routing subjects. These can be request's variables or other entities.

        .. note:: Non-custom subjects (uppercased) can be pre-optimized (during startup)
            and should be used for performance reasons.

        """
        custom = SubjectCustom

        class PATH_INFO(SubjectBuiltin):
            """Default subject, maps to PATH_INFO."""

            name = ''

        class REQUEST_URI(SubjectBuiltin):
            """Checks REQUEST_URI for a value."""

            name = 'uri'

        class QUERY_STRING(SubjectBuiltin):
            """Checks QUERY_STRING for a value."""

            name = 'qs'

        class REMOTE_ADDR(SubjectBuiltin):
            """Checks REMOTE_ADDR for a value."""

            name = 'remote-addr'

        class REMOTE_USER(SubjectBuiltin):
            """Checks REMOTE_USER for a value."""

            name = 'remote-user'

        class HTTP_HOST(SubjectBuiltin):
            """Checks HTTP_HOST for a value."""

            name = 'host'

        class HTTP_REFERER(SubjectBuiltin):
            """Checks HTTP_REFERER for a value."""

            name = 'referer'

        class HTTP_USER_AGENT(SubjectBuiltin):
            """Checks HTTP_USER_AGENT for a value."""

            name = 'user-agent'

        class STATUS(SubjectBuiltin):
            """Checks HTTP response status code.

            .. warning:: Not available in the request chain.

            """
            name = 'status'

    class transforms(object):
        """A transformation is like a filter applied to the response
        generated by your application.

        Transformations can be chained (the output of a transformation will be the input of the following one)
        and can completely overwrite response headers.

        * http://uwsgi.readthedocs.io/en/latest/Transformations.html

        """
        chunked = ActionChunked
        fix_content_len = ActionFixContentLen
        flush = ActionFlush
        gzip = ActionGzip
        template = ActionTemplate
        to_file = ActionToFile
        upper = ActionUpper

        # todo Consider adding the following and some others from sources (incl. plugins):
        # xslt, cachestore, memcachedstore, redisstore, rpc, lua

    class actions(object):
        """Actions available for routing rules.

        Values returned by actions:

            * ``NEXT`` - continue to the next rule
            * ``CONTINUE`` - stop scanning the internal routing table and run the request
            * ``BREAK`` - stop scanning the internal routing table and close the request
            * ``GOTO x`` - go to rule ``x``

        """
        add_var_cgi = ActionAddVarCgi
        add_var_log = ActionAddVarLog
        alarm = ActionAlarm
        auth_basic = ActionAuthBasic
        auth_ldap = AuthLdap
        dir_change = ActionDirChange
        do_break = ActionDoBreak
        do_continue = ActionDoContinue
        do_goto = ActionDoGoto
        fix_var_path_info = ActionFixVarPathInfo
        header_add = ActionHeaderAdd
        header_remove = ActionHeaderRemove
        headers_off = ActionHeadersOff
        headers_reset = ActionHeadersReset
        log = ActionLog
        offload_off = ActionOffloadOff
        redirect = ActionRedirect
        rewrite = ActionRewrite
        route_external = ActionRouteExternal
        route_uwsgi = ActionRouteUwsgi
        send = ActionSend
        serve_static = ActionServeStatic
        set_harakiri = ActionSetHarakiri
        set_script_file = ActionSetScriptFile
        set_uwsgi_process_name = ActionSetUwsgiProcessName
        set_var_document_root = ActionSetVarDocumentRoot
        set_var_path_info = ActionSetVarPathInfo
        set_var_remote_addr = ActionSetVarRemoteAddr
        set_var_remote_user = ActionSetVarRemoteUser
        set_var_request_method = ActionSetVarRequestMethod
        set_var_request_uri = ActionSetVarRequestUri
        set_var_script_name = ActionSetVarScriptName
        set_var_uwsgi_appid = ActionSetVarUwsgiAppid
        set_var_uwsgi_home = ActionSetVarUwsgiHome
        set_var_uwsgi_scheme = ActionSetVarUwsgiScheme
        signal = ActionSignal

        # todo Consider adding the following and some others from sources (incl. plugins):
        # cachestore, cacheset, memcached,
        # router_cache: cache, cache-continue, cachevar, cacheinc, cachedec, cachemul, cachediv
        # rpc,
        # rpc: call, rpcret, rpcnext, rpcraw, rpcvar,
        # access, spnego, radius
        # xslt, ssi, gridfs
        # cgi: cgi, cgihelper
        # router_access: access,
        # proxyhttp -router_http, proxyuwsgi -router_uwsgi, xattr -xattr
        # router_memcached: memcached, memcached-continue, memcachedstore
        # router_redis: redis, redis-continue, redisstore

    def __init__(self, action, subject=subjects.PATH_INFO('(.*)'), stage=stages.REQUEST):
        """
        :param RouteAction action: Action (or transformation) to perfrom.
            See ``.actions`` and ``.transforms``.

        :param SubjectCustom|SubjectBuiltin subject: Subject to verify before action is performed.
            See ``.subjects``.

        :param str|unicode stage: Stage on which the action needs to be performed.
            See ``.stages``.

        """
        if subject is None:
            subject = 'run'  # always run the specified route action

        subject_rule = ''

        self._custom_subject = isinstance(subject, SubjectCustom)

        if self._custom_subject:
            subject_rule = subject
            subject = 'if-not' if subject.negate else 'if'

        elif isinstance(subject, SubjectBuiltin):
            subject_rule = subject.regexp
            subject = subject.name

        self.command_label = ('%s-route-label' % stage).strip('-')
        self.command = ('%s-route-%s' % (stage, subject)).strip('-')
        self.value = subject_rule, action


class Routing(OptionsGroup):
    """Routing subsystem.

    You can use the internal routing subsystem to dynamically alter the way requests are handled.

    .. note:: Since 1.9

    * http://uwsgi.readthedocs.io/en/latest/InternalRouting.html
    * http://uwsgi.readthedocs.io/en/latest/Transformations.html

    """

    route_rule = RouteRule

    class modifiers(object):
        """Routing modifiers.

        * http://uwsgi.readthedocs.io/en/latest/Protocol.html

        """
        WSGI = ModifierWsgi
        PSGI = ModifierPsgi
        LUA = ModifierLua
        RACK = ModifierRack
        JVM = ModifierJvm
        CGI = ModifierCgi
        MANAGE = ModifierManage
        GCCGO = ModifierGccgo
        PHP = ModifierPhp
        MONO = ModifierMono
        SPLOOER = ModifierSpooler
        SYMCALL = ModifierSymcall
        SSI = ModifierSsi
        EVAL = ModifierEval
        XSLT = ModifierXslt
        V8 = ModifierV8
        GRIDFS = ModifierGridfs
        FASTFUNC = ModifierFastfunc
        GLUSTERFS = ModifierGlusterfs
        RADOS = ModifierRados
        MANAGE_PATH_INFO = ModifierManagePathInfo
        MESSAGE = ModifierMessage
        MESSAGE_ARRAY = ModifierMessageArray
        MESSAGE_MARSHAL = ModifierMessageMarshal
        WEBDAV = ModifierWebdav
        SNMP = ModifierSnmp
        RAW = ModifierRaw
        MULTICAST_ANNOUNCE = ModifierMulticastAnnounce
        MULTICAST = ModifierMulticast
        CLUSTER_NODE = ModifierClusterNode
        REMOTE_LOGGING = ModifierRemoteLogging
        RELOAD_BRUTAL = ModifierReloadBrutal
        RELOAD = ModifierReload
        CONFIG_FROM_NODE = ModifierConfigFromNode
        PING = ModifierPing
        ECHO = ModifierEcho
        LEGION_MSG = ModifierLegionMsg
        SIGNAL = ModifierSignal
        CACHE = ModifierCache
        COREROUTER_SIGNAL = ModifierCorerouterSignal
        RPC = ModifierRpc
        PERSISTENT_CLOSE = ModifierPersistentClose
        SUBSCRIPTION = ModifierSubscription
        EXAMPLE = ModifierExample
        RESPONSE = ModifierResponse

    def register_route(self, route_rules, label=None):
        """Registers a routing rule.

        :param RouteRule|list[RouteRule] route_rules:

        :param str|unicode label: Label to mark the given set of rules.
            This can be used in conjunction with ``do_goto`` rule action.

            * http://uwsgi.readthedocs.io/en/latest/InternalRouting.html#goto

        """
        route_rules = listify(route_rules)

        if route_rules and label:
            self._set(route_rules[0].command_label, label, multi=True)

        for route_rules in route_rules:
            self._set(route_rules.command, route_rules.value, multi=True)

        return self._section

    def print_routes(self):
        """Print out defined routes."""

        self._set('routers-list', True, cast=bool)

        return self._section

    def set_error_page(self, status, html_fpath):
        """Add an error page (html) for managed 403, 404, 500 response.

        :param int status: HTTP status code.

        :param str|unicode html_fpath: HTML page file path.

        """
        statuses = [403, 404, 500]

        status = int(status)

        if status not in statuses:
            raise ConfigurationError(
                'Code `%s` for `routing.set_error_page()` is unsupported. Supported: %s' %
                (status, ', '.join(map(str, statuses))))

        self._set('error-page-%s' % status, html_fpath, multi=True)

        return self._section
